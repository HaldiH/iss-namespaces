+++
weight = 50
+++

# Exploits

---

{{% section %}}

## CVE-2019-5736: A runC vulnerability

---

### Principle

Exploit _procfs_ and _runC_.

- `/proc/self/exe` gives a symlink to the current process executable path
- `/proc/self/fd` is a directory containing the file descriptors open by the process
- runC is a container runtime for Docker (default)

---

### Vulnerability

- Allows a malicious container to overwrite the host `runc` binary
- Can exploit any of this two situations:
  - Creating a new container using a malicious image
  - Attaching (`docker exec`) into an existing container which the attacker had previous write access to

---

- When creating or attaching to a container, runC creates a `runc init` subprocess to setup all needed restrictions on itself to prevent the called process to escape the container
- Then `runc init` will `execve` the requested binary and create a new process inside the container

---

![runC init](runc_init1.jpg)

---

The attack consist in replacing the binary to execute by `/proc/self/exe` so `runc init` will execute itself

![runC init trick](runc_init2.jpg)

---

Why is it working ? `/proc/self/exe` should be a symlink to something like `/usr/sbin/runc`, so `execve` should try to execute `/usr/sbin/run` from the container right ?

{{% fragment %}}_procfs_ is a special filesystem. `/proc/[pid]/exe` does not follow the normal semantics for symlinks. When a process open `/proc/[pid]/exe` the kernel gives access to the open file entry directly.{{% /fragment %}}

---

However, we cannot overwrite the runC binary while the process is running. But if the runC process exits, `/proc/[runc-pid]/exe` will disapear and we will lose the reference to the runC binary.

So we have to:

<ul>
<li>{{% fragment %}}first identify the PID of runC{{% /fragment %}}</li>
<li>{{% fragment %}}then open in read only `/proc/[runc-pid]/exe`{{% /fragment %}}</li>
<li>{{% fragment %}}finally, wait that runC exits to open in write mode `/proc/self/fd/[ro-runc-fd]`{{% /fragment %}}</li>
</ul>

---

Once the runC binary has been replaced, the system is infected and the attacker can gains root access to the host.

This breach has been patched by copying the runC executable inside a temporary filesystem so that any modifications made on runC will be discarded.

{{% /section %}}

---

{{% section %}}

## Exploit capabilities: CAP_SYS_MODULE

---

### Principle

- Run an infected image with CAP_SYS_MODULE capability
- Exploit the kernel module injection within a running container
- Open a reverse shell to a listening socket in the attacker system

---

We create a container with a malicious image and give the CAP_SYS_MODULE capability to the container. The image contains a kernel module that will create a reverse shell to the attack IP address.

The command `insmod` will insert a module into the kernel. Since we gave the CAP_SYS_MODULE capability to the container, the syscall will succeed and modify the host kernel.

---

### Demo

---

The container has to run as root, as for the docker engine, otherwise the syscall will be denied.

The moral of this story is that you have to pay attention to what privileges and capabilities you give to a container, try to run containers as non-root user or use user namespace ID binding, and use root-less docker engine if you can.

{{% /section %}}
